[source](https://juejin.im/book/5a8f9ddcf265da4e9f6fb959/section/5a8f9fcb6fb9a063417b3f9e#heading-5)
[source](https://juejin.im/post/5b06ba5051882538953ac7e5)

- 快速排序， 利用分治的方法，递归。左边小于右边，中间有基准
分治 logN 再排序N,
时间复杂度为O(N*logN)

- 归并算法， 先用递归将数组分解成足够小的数组
再合并， 

- 冒泡排序  冒泡， 近邻比较
  一次循环排好一个最大的数到最后面
  两重循环 O(n^2)

- 选择排序
  找到数组中的最小（大）值
  并将其放到第一位，然后找到第二小的值放到第二位

- 插入排序
  接近生活
  打牌时， 
  第二项开始，遍历数组的n-1项，
  左边会保持顺序, 很好理解

  


- 三种排序算法， 冒泡排序， 选择排序和插入排序， 时间复杂度为
O(n^2), 冒泡排序实现最简单， 性能最差， 选择排序比冒泡稍好， 但是还不够， 插入排序是三者中表现最好的， 小数集效率较高。 



归并排序， 先用递归拆分数组， 只有一个元素






分治的算法思想， 通过对数据进行分类处理， 不断降低数量级，实现O(logN)(对数级别， 比O(n)这种线性复杂度更低的一种， 快排核心是二分法的O(logN), 实现复杂度为O(N*logN)的复杂度)

快速排序

流程：
  1. 随机选择数组中的一个数， 为基准
  2. 其他数字跟这个数进行比较， 比这个数小的放在其左边， 大的放在右边。
  3. A左边为小于A的， 右边为大于A的
  4. 递归上面的过程

  - 归并排序 O(N*logN) 
  核心思想也是分治， 通过递归将问题分解成相同或者类型相关的两个或多个子问题， 直到问题简单到足以解决， 然后将子问题的解决方案结合起来， 解决原始方案的一种思想。

  将复杂的数组分解成足够小的数组（只包含一个元素）, 然后通过合并两个有序数组来达到综合子问题解决方案的目的。

  如何整合两个有序数组， 拆分数组只是一个辅助过程。

  var arr = [8, 7, 6, 5]
  [8, 7] 和 [6, 5]
  [8] [7] [6] [5]
  [7, 8] [5, 6]
  [5, 6, 7, 8]

  合并后的数组是有序的

- 冒泡排序
  沉淀排序(sinking sort)
  遍历整个数组， 将数组的每一项与其后一项进行对比， 不符合要求就对换位置， 一共遍历n轮， 气泡从水底冒到水面一样泡到数组未端， 冒泡排序
  效率最低， 嵌套了两轮循环， O(n^2)

- 选择排序
  原址比较排序法， 大致思路：

找到数组中最小值， 放在第一位， 再找到


- 插入排序

2  1  3  5  4  3
2  2  3  5  4  3
1  2  3  5  4  3
1  2  3  5  5  3
1  2  3  4  5  3
1  2  3  4  5  5 
1  2  3  4  4  5
1  2  3  3  4  5



