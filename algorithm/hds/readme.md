[source](https://juejin.im/post/5b3608336fb9a00e765e8ed4)
[source](http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/)

- 简单的二叉树
- 简单的满二叉树
- 简单的完全二叉树
- 简单的堆
- 简单的堆分类

堆
  <-二叉树
  每一个节点最多两个分支的树结构， 左子树和右子树
  ![二叉树](https://user-gold-cdn.xitu.io/2018/6/29/1644b1037a8c7413?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

  左右次序.

  第i层最多拥有 2^(i-1)个节点
  深度为K的二叉树最多共有2^(k+1)-1个节点
  根节点所有的层级i=0 所在深度k=0

### 简单的满二叉树

深度为k, 第i 层拥有 2^(i-1)个节点, 共拥有2^(k+1)-1                         

二叉树的每一层都是满的， 除了最后一层上的节点，每一层都具有左节点和右节点。

### 简单的完全二叉树
深度为k, 共有n个节点，当且仅当其中的每一个节点， 都可以和同样深度为K的满二叉树时， 按层序号编相同的节点，也就是序号为1到n的节点， 均一一对应时。

### 简单的堆
堆(Heap) 一类特殊的数据结构的统称， 通常是一个可以被看作一棵树的数组对象

堆的实现是通过构造二叉堆，实为二叉树的一种。
堆是完全二叉树
![heap](https://user-gold-cdn.xitu.io/2018/6/29/1644b1037d4c722a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

某个节点的下标idx, 这个节点的父节点与孩子节点的下标

```js
var getParentPos = function(idx) {
  return Math.floor(idx/2);
}

var getLeftChildPos = function(idx) {
  return 2*idx
}

var getRightChildPos = function(idx) {
  return 2*idx + 1;
}
```

将堆转变为数组时， 数组的初始化下标始终为0， 所以我们的堆数据结构模型在此时要发生如下改变。

### 简单的堆分类
大顶堆  小顶堆
每个节点都大于或等于其左右孩子节点的值，
假设有一个堆，小于或等于其左右孩子节点的值， 小顶堆

算法介绍
轻松实现大顶堆调整
轻松创建大顶堆
轻松实现堆排序
复杂度分析

堆排序，利用堆（大顶堆）进行排序的方法
思想：将待排序的数组构成一个大顶堆。 最大值就是堆顶的根节点。将它移走， 与堆组的未层元素交换， 未层元素就是最大值， 将乘余的n-1个元素又重新构造成堆，次大值， 如此反复， 就是一个有序数组了。 

- 大顶堆调整（Max-Heapify）将堆的未端子节点做调整，使得子节点永远小于父节点
- 创建大顶堆（Build-Max-Heap） 将堆中所有数据调整位置， 使其成为大顶堆
- 堆排序（Heap-Sor）移除在堆顶的根节点， 并做大顶堆调整的迭代运算。
